---
title: 环境配置
permalink: /tutorials/python/basic-th/
---

# python 程序开发过程

python程序的执行过程可分为3步，首先是源代码编写，其次是程序编译与执行，最后的程序的封装与打包。

![程序开发过程](/assets/images/python/python-process.JPG)

- 在源代码编写阶段需要选择合适的编译器，选择解释器版本，设计好自己的工程目录。
- 编译阶段，会通过解析器将源码转化为字节码，再有虚拟机将字节码转化为机器语言，最后才在硬件上运行。与编译性语言（c/c++）相比，多出了编译和链接的过程，性能会下降；Python并不是每次都需要转换字节码，解释器在转换之前会判断代码文件的修改时间是否与上一次转换后的字节码pyc文件的修改时间一致，若不一致才会重新转换。
- 程序执行完以后，进行程序封装与打包，根据使用场景，进行不同的代码管理。其中或涉及程序封装，程序加密，版本管理等操作。

## python编译器选择
- PyCharm： 
  - 优点：
      - 支持智能代码补全、语法高亮和错误提示等功能。
      - 内置调试工具和版本控制功能，便于团队协作和代码调试。
      - 集成了很多第三方插件和库，支持多种Python Web框架。
  - 缺点：
      - 相比其他Python IDE，PyCharm较为笨重，需要一定的计算机性能和内存支持。
      - 部分功能需要付费使用。
  - 教程：[PyCharm官方文档](https://www.jetbrains.com/help/pycharm/)
    
- Visual Studio Code (VSCode)：
    - 优点：
      - 轻量级的文本编辑器，支持多种编程语言，功能丰富。
      - 支持自定义快捷键和主题。
      - 内置Python插件，支持调试、智能补全、代码重构等功能。
    - 缺点：
      - 对于Python开发来说，有些功能不够完善，如自动导入等。
      - 不支持像PyCharm一样的智能提示。
    - 教程：[VSCode官方文档](https://code.visualstudio.com/)
  
  - Jupyter Notebook：
    - 优点：
      - 交互性强，可以边编写代码边做数据分析和可视化。
      - 有丰富的扩展库，支持多种数据科学和机器学习任务。
      - 便于与其他人分享笔记本和代码。
    - 缺点：
      - 对于大型项目的开发来说，不太方便。
      - 不适用于生产环境。
    - 教程：[Jupyter官方文档](https://jupyter.org/)
    
  - Spyder：
    - 优点：
      - 专门针对数据科学和计算机模拟等领域开发，集成了很多科学计算相关的库。
      - 内置调试工具和变量查看器等功能。
    - 缺点：
      - 界面较为简单，可能不够美观和友好。
    - 教程：[Spyder官方文档](https://www.spyder-ide.org/)

笔者最开始使用的是spyder，现在基本都以pycharm和jupyter notebook为主。
- 入门学习推荐spyder和jupyter notebook,可以随时查看变量的值，方便调试，基础环境包较多，覆盖较多场景;
- 需求不明确，需要边写边测边分析，建议jupyter notebook；
- 工程化应用，需求复杂，需要打包上架，版本管理等，建议pycharm与VSCode。
使用教程除了官方文库外，可参考如下：
- [jupyter教程](https://mp.weixin.qq.com/s/pGK7jsyp00j95YvFAJDDOw)
- [pycharm教程](https://mp.weixin.qq.com/s/IhFtosWjOhZ5cJ77X7XYfg)
- [spyder教程](https://mp.weixin.qq.com/s/wAV4ulCthQPnbypDfhQczg)

## python解释器选择
python过去一共有两个大的版本，python2和python3,两个无法兼容,现python2已经停止更新，建议使用python3.8及以上。
当创建一个工程项目时，需要安装不同的三方包，若所有的工程都使用同一个解释器，项目变多，三方包就会特别多，很容易出现不同的包之间互相冲突，因此需要进行解释器环境管理。
解释器环境分为本地真实环境和虚拟环境。
- 真实环境指真实下载安装的python，一般是下载的安装包直接安装路径，如果安装在项目工程目录下，可以随项目工程打包带走，适用于单机版软件，更换设备时无需环境配置。
- 虚拟的环境是创建隔离的Python，它允许你为每个项目创建一个独立的环境，从而避免不同项目之间的依赖冲突。虚拟环境的创建和管理方式与编译器软件有关，一般会选择基础编译器（真实环境下安装包安装位置），在基础编译器基础上进行三方包管理，不同工程项目的虚拟环境相互隔离，不会产生冲突。笔者习惯创建纯净版真实环境下的python包，并以它作为基础，作为其他项目虚拟环境创建基础。

# 三方包安装

## 终端操作
需要确定pip的位置，cmd进入终端，直接使用pip安装，一般会直接调用根目录的python环境中的pip，即加入环境变量中的python包，实际操作中，需调用时候环境下的pip，一般在/venv/Scripts下。


```python
cd venv/Scripts # 进入待安装环境下的目录
pip install pandas  # 安装pandas
pip install pandas==1.18.0  # 指定pandas的版本
pip install pandas -i https://mirrors.aliyun.com/pypi/simple/  # 如果安装速度太慢，指定国内镜像源
pip install -r requirements.txt # 安装 requirements.txt 中的依赖

pip list  # 列出已经安装的包

conda install package_name  # 使用conda 进行管理安装，需先激活conda环境

pip install *.whl  # 安装下载到本地的
# github下，三方包的安装，
python setup.py install
```

## 镜像环境
如果直接安装速度慢，可以尝试替换镜像源，镜像源可以参考如下：
- 清华镜像站：[https://pypi.tuna.tsinghua.edu.cn/simple](https://pypi.tuna.tsinghua.edu.cn/simple)
- 阿里云镜像站：[https://mirrors.aliyun.com/pypi/simple/](https://mirrors.aliyun.com/pypi/simple/)
- 中科大镜像站：[https://pypi.mirrors.ustc.edu.cn/simple/](https://pypi.mirrors.ustc.edu.cn/simple/)
- 中国科技大学镜像站：[https://pypi.mirrors.ustc.edu.cn/simple/](https://pypi.mirrors.ustc.edu.cn/simple/)
- 中国科学技术大学镜像站：[https://pypi.mirrors.ustc.edu.cn/simple/](https://pypi.mirrors.ustc.edu.cn/simple/)


# 编码规范与工程管理


## 编码规范
python 源代码的编写具有一套强制性规则，像对齐，变量定义的风格，函数参数的顺序等，可以参考[PEP8](https://www.python.org/dev/peps/pep-0008/)。

## 工程目录管理推荐

```plain
project_name/
|--data  # 存放数据，输入和输出数据
|--doc  # 文档记录
|--source/  # 源代码
|  |-- module1/  # 模块1
|  |  |--__init__.py
|  |  |--module1_1.py  # 含有函数function1()
|  |  |--modele1_2.py  # 含有函数function2()
|  |--module2/  # 模块2
|  |  |--__init__.py
|  |  |--module2_1.py  # 含有函数function3()
|  |  |--module2_2.py  # 含有函数function4()
|  |--main.py  # 程序入口
|--test  # 测试脚本
|--venv  # 工程环境
|--readme.md  # 工程说明
```

## 模块依赖关系
## 如何正确导入包中的函数？
假设 module1目录下__init__.py文件内容如下：
```python
from .module1_1 import function1
from .module1_2 import function2
```
module2目录下的__init__.py文件内容如下：
```python
from .module2_1 import function3
from .module2_2 import function4
```

则在main.py文件中可直接导入函数function1,function2,function3,function4
```python
form module1 import function1,function2
form module2 import function3,function4

function1()
function2()
```
加入在source下的一级目录加上__init__(),即将source当成一个包，则可在__init__()中加上

```python
from .module1 import function1,function2
from .module2 import function3,function4
```
则可直接在直接：
```python
form source import  function1,function2, function3,function4
```

## 如何导入相关目录下的函数？
即module1_1.py中导入module2_2.py 中的函数function4()

```python
# 错误导入方式
from ..module2 import function4
from ..module2.module2_2 import function4
from source import function4

ImportError: attempted relative import with no known parent package

# 可行方式
from source.module2.module2_2 import function4
from source.module2 import function4
```


# 程序打包与封装

项目打包分为两种类型：
● 单文件类型，即所有源代码，依赖包都打包进exe文件中；迁移拷贝都只有一个文件；
● 文件夹类型，封装源代码和依赖文件。

## 封装工具:pyinstaller
### 安装
```python
pip install pyinstaller
```

### 使用
```python
pyinstaller run.py
```
上述code会在工作目录生成build、dist文件夹和run.spec文件。
- build目录，存放日志文件和工作文件
- dist目录，存放可执行文件
- run.spec,配置文件

### 生成带文件目录的可执行程序

```python
- pyinstall -D run.py
```
假如程序中依赖相关文件，或者含有外部数据，可在*.spec文件中进行修改
主要修改参数：
- datas：
- pathex：

```text

a = Analysis(
    ['run.py'],
    pathex=['E:/pycharm_app/yolo-app/'],
    binaries=[],
    datas=[('source/img/ui2.jpg',"source/img")],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
```

### 添加软件图标
```python
pyinstaller --icon=path/to/your/icon.ico --onefile your_script.py
```
或者直接写入spec文件：icon="doc/ui.ico"
```text

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='run',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon="doc/ui.ico"
)

```
指定可执行文件生成位置：
```python
--distpath /path/to/your/output/folderpyinstaller --distpath /path/to/your/output/folder your_script.spec
```

## 生成单个文件
```python
pyinstall -F run.py
```


